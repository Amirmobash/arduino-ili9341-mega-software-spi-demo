#include "Adafruit_GFX.h"
#include "Adafruit_ILI9341.h"
#include "SPI.h"

#include <EEPROM.h>
#define eep 0
int eeAddress=1;
unsigned int eep_number_cat[1000];
// For the Adafruit shield, these are the default.
int TFT_RST=26;
int TFT_DC=28;
int TFT_CS=24;

int TFT_GND=22;
int TFT_MOSI=30;
int TFT_CLK=32;
int TFT_MISO=36;
int TFT_LED=34;

String softversion="110";
 bool stop_all=false;;
#define n_pin 16  // number of Search Pin is connect to arduino
// Use hardware SPI (on Uno, #13, #12, #11) and the above for CS/DC
//Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC);
// If using the breakout, change pins as desired
// Create a new SPI port with:
// Pin 2 = MOSI,
// Pin 3 = MISO,
// Pin 4 = SCK
Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_MOSI, TFT_CLK, TFT_RST, TFT_MISO);
/*
Serial input data frome tft :
22:11:36.790 -> ILI9341 Test!
22:11:37.265 -> tft ID1: 0x10
22:11:37.265 -> tft ID2: 0x85
22:11:37.299 -> tft ID3: 0x52
22:11:37.299 -> tft ID4: 0x0
22:11:37.333 -> tft Power Mode: 0x9C
22:11:37.367 -> MADCTL Mode: 0x48
22:11:37.367 -> Pixel Format: 0x5
22:11:37.401 -> Image Format: 0x80
22:11:37.401 -> Self Diagnostic: 0xC0
22:11:37.435 -> Benchmark                Time (microseconds)
22:11:37.503 -> Screen fill              1496780
22:11:39.437 -> Text                     154492
22:11:42.898 -> Lines                    1270596
22:11:49.612 -> Horiz/Vert Lines         125400
22:11:50.535 -> Rectangles (outline)     82812
22:11:51.418 -> Rectangles (filled)      3107224
22:11:55.417 -> Circles (filled)         465976
22:11:56.197 -> Circles (outline)        541656
22:11:57.215 -> Triangles (outline)      281660
22:11:58.299 -> Triangles (filled)       1339908
22:12:00.744 -> Rounded rects (outline)  243744
22:12:01.796 -> Rounded rects (filled)   3132716
22:12:05.730 -> Done!
*/

/*
 A >>> A
 1 >>> 3
 2 >>> 6
 3 >>> 1
 4 >>> 4
 5 >>> 5
 6 >>> 2
 7 >>> 7
 8 >>> 8
 B >>> B
 */

//#define Debug 0 // if need to check data logs in app uncommand this line
#define data_size 200
int SH1 =23;   // (SH1)Clock pin of 74HC595 is connected to Digital pin 6
int DS1 =25;    // (DS1)Data pin of 74HC595 is connected to Digital pin 4
int ST1 =27;   // (ST1)Latch pin of 74HC595 is connected to Digital pin 5

int SH2 =29;   // (SH2)Clock pin of 74HC595 is connected to Digital pin 6
int DS2 =31;    // (DS2)Data pin of 74HC595 is connected to Digital pin 4
int ST2 =33;   // (ST2)Latch pin of 74HC595 is connected to Digital pin 5

//int MR = A0;    // Data pin of 74HC595 is connected to Digital pin 4
int MR = 14;    // Data pin of 74HC595 is connected to Digital pin 4

int JUMP = 15;    // Data pin of 74HC595 is connected to Digital pin 4
int STAT = 16;    // Data pin of 74HC595 is connected to Digital pin 4

unsigned long leds1 = 0;      
unsigned long leds2 = 0;      
String color="";
char inputString[200],n=0,W1=0,W2=0,W1_S=0,j=0;         
bool stringComplete = false;  // whether the string is complete
bool start_mode=false,verify_mode=false,Process_mode=false,build_request=false;
bool state=false;
bool state_jump=false,one_more=false;
////////////////////////////////////////////////////////////////////
void serialEvent();
/////////////////////////////////////////////////////////////////////
/*#define BLACK 0x0000 // U16 definition
#define RED 0x001F
#define GREEN 0x07E0
#define DARKGREEN 0x0408
#define WHITE 0xFFFF
#define GREY 0x8410
#define YELLOW 0xFFE0
#define BLUE 0XF800 
#define ORANGE 0x01FF
#define LIGHTCYAN 0x87FF
#define PINK 0xF81F
#define CYAN    0x07FF
#define MAGENTA 0xF81F
*/
#define BLACK 0xFFFF
#define NAVY 0x000F
#define DARKGREEN 0x03E0
#define DARKCYAN 0x03EF
#define MAROON 0x7800
#define PURPLE 0x780F
#define OLIVE 0x7BE0
#define LIGHTGREY 0xC618
#define DARKGREY 0x7BEF
#define BLUE ~0xF800
#define ORANGE 0xFFE0
#define CYAN ~0xFC00
#define RED 0xFFE0
#define GREEN 0xFC1F
#define GRAY 0xC618
#define WHITE 0x0000
#define YELLOW 0xF800
#define MAGENTA 0xAFE5
#define PINK 0xF7E0
/////////////////// WHITE   BLACK  BLUE   PINK  ORANGE    GRAY  GREEN  CYAN    YELLOW  RED
uint32_t colorS[20]={0X0000,0XFFFF,~0XF800,0XF7E0,0XFFE0,0XC618,0XFC1F,~0XFC00,0XF800,0XFFE0};
// PICTURE HEX CODE
static const uint8_t ROCK[] PROGMEM = { 
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xc1,0xff,0xff,0xff,0xff,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0x80,0xff,0xff,0xff,0xff,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0x80,0x7f,0xff,0xff,0xff,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0x80,0x7f,0xff,0xff,0xff,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0x80,0x7f,0xff,0xff,0xff,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0x80,0x3f,0xff,0xff,0xfe,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0x80,0x3f,0xff,0xff,0xfe,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0x80,0x3f,0xff,0xff,0xfe,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0x80,0x3f,0xff,0xff,0xfe,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0x80,0x3f,0xff,0xff,0xfe,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xc0,0x1f,0xff,0xff,0xfe,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xc0,0x1f,0xff,0xff,0xfe,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xc0,0x1f,0xff,0xff,0xfe,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xc0,0x1f,0xff,0xff,0xfe,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xc0,0x1f,0xff,0xff,0xfc,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xc0,0x0f,0xff,0xff,0xfc,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xe0,0x0f,0xff,0xff,0xfc,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xe0,0x0f,0xff,0xff,0xfc,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xe0,0x0f,0xff,0xff,0xfc,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xe0,0x0f,0xff,0xf0,0x3c,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xe0,0x07,0xff,0xe0,0x1c,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf0,0x07,0xff,0xe0,0x1c,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf0,0x07,0xe3,0xe0,0x1c,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf0,0x07,0x80,0xe0,0x08,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf0,0x03,0x00,0xe0,0x0c,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf0,0x03,0x00,0x60,0x0c,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf0,0x03,0x00,0x60,0x0c,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf8,0x03,0x00,0x60,0x0c,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf8,0x03,0x00,0x60,0x0c,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf8,0x03,0x00,0xff,0x8c,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf8,0x03,0x01,0xff,0xff,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf8,0x01,0x01,0x80,0x3f,0xf0,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xf8,0x01,0x81,0x80,0x00,0x78,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x01,0x81,0x80,0x00,0x1c,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x01,0x81,0x80,0x00,0x0c,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x01,0x81,0x80,0x00,0x06,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x01,0x80,0xc0,0x00,0x07,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x01,0x80,0xe0,0x00,0x03,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x01,0x80,0x70,0x00,0x01,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x00,0xc0,0x38,0x00,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x00,0xc0,0x1f,0x00,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x00,0xc0,0x1f,0xe0,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x00,0xc0,0x31,0xf8,0x00,0x3f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfc,0x00,0xe0,0x30,0x18,0x00,0x1f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfe,0x00,0x70,0xe0,0x18,0x00,0x1f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfe,0x00,0x3f,0xc0,0x38,0x00,0x1f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfe,0x00,0x0f,0x00,0xf0,0x00,0x1f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfe,0x00,0x00,0x01,0xc0,0x00,0x1f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfe,0x00,0x00,0x03,0x80,0x00,0x1f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xfe,0x00,0x00,0x07,0x00,0x00,0x1f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0x00,0x00,0x06,0x00,0x00,0x3f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0x00,0x00,0x0c,0x00,0x00,0x3f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0x00,0x00,0x04,0x00,0x00,0x3f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x7f,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x01,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x01,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x03,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x03,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x07,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x1f,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x3f,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x7f,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x01,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x0f,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0
};

int Lo1 = 0;
int Lo2 = 0;
int Lo3 = 0;
int Lo4 = 0;
int Lo5 = 0;
int Lo6 = 0;
int Lo7 = 0;
int Lo8 = 0;
int testeth1=0;
int cavo = 0;
char buff_Lo[4],verifi=0;

int R[14]={A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12}; // پینهای قرمز
int G[11]={2,3,4,5,6,7,8,9,10,11};// پینهای سبز 
int led_state=13;

bool Test_mode=false,menu1=true,menu2=false;

const int X = A14;
const int Y = A13;
const int SW = A15;
int b = 0;
int x = 0;
int y = 0;
const int MaxReadings = 10;
int Xreadings[MaxReadings];
int XreadIndex = 0;
int Xtotal = 0;
int X_Pos = 0;
int Yreadings[MaxReadings];
int YreadIndex = 0;
int Ytotal = 0;
int Y_Pos = 0;
bool up=0,down=0,left=0,right=0,m_n=false;

void Smoother(int x_pin, int y_pin)
{
  Xtotal = Xtotal - Xreadings[XreadIndex];
  Ytotal = Ytotal - Yreadings[YreadIndex];
  delay(1);
  Xreadings[XreadIndex] = analogRead(x_pin);
  Yreadings[YreadIndex] = analogRead(y_pin);
  delay(1);
  Xtotal = Xtotal + Xreadings[XreadIndex];
  Ytotal = Ytotal + Yreadings[YreadIndex];
  delay(1);
  XreadIndex = XreadIndex + 1;
  YreadIndex = YreadIndex + 1;
  if (XreadIndex >= MaxReadings) XreadIndex = 0;
  if (YreadIndex >= MaxReadings) YreadIndex = 0;
  delay(1);
  X_Pos = Xtotal / MaxReadings;
  Y_Pos = Ytotal / MaxReadings;
}
void setup() {
  //delay(1000);
  
  //Serial.println("Wellcom"); 

  // Set all the pins of 74HC595 as OUTPUT
  pinMode(SH1, OUTPUT);
  pinMode(DS1, OUTPUT);  
  pinMode(ST1, OUTPUT);

  pinMode(SH2, OUTPUT);
  pinMode(DS2, OUTPUT);  
  pinMode(ST2, OUTPUT);
  
  pinMode(MR, OUTPUT);
  pinMode(STAT, OUTPUT);
  pinMode(TFT_RST, OUTPUT);
  pinMode(TFT_CS, OUTPUT);
  pinMode(TFT_DC, OUTPUT);
  pinMode(TFT_GND, OUTPUT);
  digitalWrite(TFT_GND, LOW);
  pinMode(TFT_LED, OUTPUT);
  digitalWrite(TFT_LED, HIGH);

  digitalWrite(TFT_RST, HIGH);
  pinMode(JUMP, INPUT_PULLUP);
  digitalWrite(MR, HIGH);

  pinMode(SW, INPUT_PULLUP) ;
  pinMode(X, INPUT) ;
  pinMode(Y, INPUT) ; 
  for (int i = 0; i < MaxReadings; i++) {
    Xreadings[i] = 0;
    Yreadings[i] = 0;
  }

  for(int in=0;in<13;in++){
    pinMode(R[in], INPUT) ;
    digitalWrite(R[in], LOW);
    if(in<10){
      pinMode(G[in], OUTPUT) ;
      digitalWrite(G[in], LOW);
    }
  }

  pinMode(led_state, OUTPUT) ;
  digitalWrite(led_state, HIGH);
  delay(500);
  pinMode(led_state, OUTPUT) ;
  digitalWrite(led_state, LOW); 
  Serial.begin(9600);
  Serial.print("begin:OK\n");
  Serial.println("version:"+softversion);
  
  tft.begin();
  
  tft.setRotation(0);
  tft.invertDisplay(true);
  /*for(char i=0;i<20;i++){
  tft.fillScreen(colorS[i]);
  delay(1000);
  }*/
  
  yield();
  //Display Text
  tft.setTextSize(5);
  tft.setTextColor(ORANGE);
  tft.setCursor(0,15);
  tft.println(" Welcome");
  
  state=false;
  state_jump=false;
  W1=0;
  W2=0;
  color+=" ???";
  digitalWrite(STAT,HIGH);
  delay(1000);
  digitalWrite(STAT,LOW);
  //clear_all();

  // PRINT TEXT //
  tft.fillScreen(ORANGE);
  tft.setTextSize(5);
  tft.setTextColor(WHITE);
  tft.setCursor(0,15);
  tft.println(" ROCK HAND");

  // PRINT PICTURE
  tft.invertDisplay(false);
  //tft.drawBitmap(110,70,ETH,120,180,BLACK);
  tft.drawBitmap(110,70,ROCK,100,100,BLACK);
  delay(1000);
  tft.invertDisplay(true);
  delay(1000);
  start_mode=true;

  // بار اول که ـردوینو پروگرام میشه
  // کل حافظه را پاک میکنیم
  if(EEPROM.read(eep)!=1){
    Serial.print("EEPROM Length : ");
    Serial.println(EEPROM.length(),DEC);
    
    EEPROM.write(eep, 1);
    for (int i = 1 ; i < EEPROM.length() ; i++) {
    EEPROM.write(i, 0);
  }

  }

  // فقط جهت تست
  /*
  EEPROM.put(eeAddress, 12345678);
  delay(150);
  //Get the float data from the EEPROM at position 'eeAddress'
  long f=0;
  EEPROM.get(eeAddress, f);
  Serial.println(f,DEC);    //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float.
  
  eeAddress += sizeof(long);
  EEPROM.put(eeAddress, 87654321);
  EEPROM.get(eeAddress, f);
  Serial.println(f,DEC);    //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float.
  */
  Process_mode=false;
  Test_mode=true;
  m_n=false;
}


/*
 * loop() - this function runs over and over again
 */
void loop() 
{
// CHECK SERIAL INPUT DATA ...  
//check_serial();
// CHECK JOY STICK KEY DATA ...
  // فقط جهت تست
//while(1){
//check_key();
//}
while(Test_mode==true){
    m_n=false;
    tft.fillScreen(BLUE);// BACKGROND COLOR
    tft.setTextColor(WHITE);// TEXT COLOR
    tft.setTextSize(5);// TEXT SIZE
    tft.setCursor(0,15);
    if(menu1==true){
      tft.print("Menu 1: ");//روند 
    }
    if(menu2==true){
      tft.print("Menu 2: ");//روند 
    }
    while(digitalRead(SW)==0);
    tft.setTextSize(4);
    tft.setCursor(0,60);

    // خروجی کردن 10پین سبزرنگ به ترتیب و
    // خواندن پینهای قرمز
    Serial.println("//>>>>>>>>>>>>>>>>>>>>//");
                    
    for(int i=0;i<10;i++){
                    tft.setTextColor(GREEN);
                    tft.setCursor(0+(i*30),60);
                    Serial.print("Out : G ");
                    if(i!=0 && i!=9){
                      Serial.print(i,DEC);
                    }else{
                      if(i==0){
                        Serial.print('A');
                      }
                      if(i==9){
                        Serial.print('B');
                      }
                    }
                    Serial.print(" >>> In : R ");
                    if(i!=0 && i!=9){
                          tft.print(i);
                         }else{
                          if(i==0){
                            tft.print('A');
                          }
                          if(i==9){
                            tft.print('B');
                          }
                         }
                        
                    check_key();
                    if(m_n==true) break;
                    if(i>0){
                      digitalWrite(G[i-1],LOW);
                    }
                    digitalWrite(G[i],HIGH);
                    delay(50);
                    bool State=LOW;
                    tft.setTextColor(RED);

                    // جستجوی پین قرمز رنگ جهت شناسایی ولتاژپین
                    int m_;
                    if(menu1==true) m_=10;
                    if(menu2==true) m_=13;
                    
                    for(int j=0;j<m_;j++){
                    delay(50);
                    State=LOW;
                    State=digitalRead(R[j]);

                    // اگر پین جستجو شده دارای ولتاژ بود
                    // شماره پین نوشته شود
                    if(State==HIGH){
                      delay(10);
                      State=LOW;
                      State=digitalRead(R[j]);
                    if(State==HIGH){
                    tft.setCursor(0+(i*30),100);
                    digitalWrite(led_state, HIGH);
                    int P=0;
                    if(j!=0 && j!=(m_-1)){
                      Serial.println(j,DEC);
                      P=j;
                    }else{
                      if(j==0){
                        Serial.println('A');
                        P='A';
                      }
                      if(j==9){
                        Serial.println('B');
                        P='B';
                      }
                    }
                    if(menu1==true){
                    if(j!=0 && j!=9){
                          tft.print(j);
                         }else{
                          if(j==0){
                            tft.print('A');
                          }
                          if(j==9){
                            tft.print('B');
                          }
                         }
                    }
                    if(menu2==true){
                    if(j!=12){
                          tft.print(j+1);
                         }else{
                          tft.print('P');
                         }
                    }
                    delay(100);
                    digitalWrite(led_state, LOW);
                    break;
                         }
                    }
                    //check_key();
                    if(m_n==true) break;
                    }
                    
                    // اگر بعد از اتمام جستجو
                    // اگر هیچکدام از پینهای قرمز ولتاژ نداشت:
                    // علامت X نمایش بدهد!
                    if(State==LOW){
                     tft.setCursor(0+(i*30),100);
                     tft.write('X');
                     Serial.println('X');
                     
                                  }
                     }
                     digitalWrite(G[9],LOW);
                     Serial.println("//====================//");
}
//============================//
}// END LOOP
 /*
  SerialEvent occurs whenever a new data comes in the hardware serial RX. This
  routine is run between each time loop() runs, so using delay inside loop can
  delay response. Multiple bytes of data may be available.
*/
void serialEvent() {
  while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString[n++]= inChar;
    // if the incoming character is a newline, set a flag so the main loop can
    // do something about it:
    if (inChar == '\n') {
      stringComplete = true;
      check_serial();
    }
  }
}
///////////////////////////////////////////////////////////////////////
void check_serial(void){
    if (stringComplete) {
    char error=3;
    #ifdef Debug
    Serial.println(inputString);
    #endif
    stringComplete = false;
    if(strstr(inputString,"begin")){
      Serial.print("begin:OK\n");
    }

    if(strstr(inputString,"version")){
      Serial.println("version:"+softversion);
    }

    if(strstr(inputString,"Stop")|| strstr(inputString,"End")){
      Serial.println("Stop:OK");
     start_mode=false;
     verify_mode=false;
     Process_mode=false;
     build_request=false; 
     stop_all=true;
      tft.fillScreen(MAGENTA);
      tft.setTextColor(WHITE);
      tft.setTextSize(5);
      tft.setCursor(5,100);
      tft.print(" Stop All   ");
     //clear_all();
    }
    
    if(strstr(inputString,"Start")){
     start_mode=true;
     verify_mode=false;
     Process_mode=false;
     build_request=false; 
     stop_all=false;
    }else{
    if(strstr(inputString,"Verify")){
     start_mode=false;
     verify_mode=true;
     Process_mode=false;
     build_request=false; 
     stop_all=false;
    }else{
     if(strstr(inputString,"Build") ){
     if(Process_mode==false){
      Serial.println("Build:OK");
     start_mode=false;
     verify_mode=false; 
     Process_mode=true;
     one_more=false;
     build_request=false; 
     stop_all=false;
     }
     //build_request=false;
    }else{
     start_mode=false;
     verify_mode=false;
     Process_mode=false;
     build_request=false;
//     search_loop=false;
    }  
    }
    }
    for(int j=0;j<data_size;j++){
      if(inputString[j-3]=='W' && inputString[j-2]=='1' && inputString[j-1]==':'){
       #ifdef Debug
       Serial.print("W1:"); 
       Serial.print(inputString[j]); 
       Serial.println(inputString[j+1]);
       #endif
       W1=(inputString[j]-48)*10;
       if(inputString[j+1]!='-'){
        W1+=(inputString[j+1]-48);
       }else{
        W1/=10;
       }
       error--; 
      }

      if(inputString[j-3]=='W' && inputString[j-2]=='2' && inputString[j-1]==':'){
        #ifdef Debug
        Serial.print("W2:"); 
        Serial.print(inputString[j]); 
        Serial.println(inputString[j+1]);
        #endif
        if(Process_mode==true){
                          build_request=true; 
                          error--;
        }
        if(inputString[j]!='-'){
        W2=(inputString[j]-48)*10;
        if(inputString[j+1]!='-'){
          W2+=(inputString[j+1]-48);
        }else{
        W2/=10;
             }
        }else{
          if(inputString[j+1]=='1'){
            W2='E';
          }else W2=0;
        }
        error--;  
      }

      if(inputString[j-2]=='C' && inputString[j-1]==':'){
        #ifdef Debug
        Serial.print("Color:");
        #endif
        
        color="";
        for(char c=0;c<10,inputString[j]!='\n';c++,j++){
          #ifdef Debug
          Serial.print(inputString[j]);
          #endif
          color+=inputString[j];
        }
       #ifdef Debug
       Serial.println();
       #endif
       error--; 
      }
    }

    if(error==0){
      state=false;
      if(Process_mode==true) build_request=true;
      else build_request=false;
    }
    n=0;
    for(int i=0;i<data_size;i++){
                      inputString[i]=' ';    
    }
  }
// END CHECK SERIAL INPUT DATA //
}

///////////////////////////////////////////////////////////////////////
void check_key(void){
  up=0;down=0;left=0;right=0;b=0;
  x=0;y=0;
  /*
  for(int ic=0;ic<MaxReadings;ic++){
    
  Smoother(X,Y);
  x = X_Pos;//map(X_Pos, 0, 1023, 0, 512);
  y = Y_Pos;//map(Y_Pos, 0, 1023, 0, 512);
  b = digitalRead(SW);
  }
  
  if((x>400 && y>1000) || (x>500 && y<10)){// x=512  y=1023
    up=1;
    down=0;
    left=0;
    right=0;
    Serial.println("Up");
  }

  if((x>500 && y<10) || (x>500 && y>1000)){// x=512 y=0
    up=0;
    down=1;
    left=0;
    right=0;
    Serial.println("Down");
  }
  
  if((x>1000 && y>500) || (x>1000 && y>500)){// x=1023 y=512
    up=0;
    down=0;
    left=0;
    right=1;
    Serial.println("Right");
  }
  
  if((x<10 && y>500) || (x<10 && y>500)){ // x=0   y=512
    up=0;
    down=0;
    left=1;
    right=0;
    Serial.println("Left");
  }
  
  if(up==1){
  tft.fillScreen(YELLOW);  
  }
  else
  if(down==1){
  tft.fillScreen(RED); 
  }
  else
  if(left==1){
  tft.fillScreen(GREEN); 
  }
  else
  if(right==1){
  tft.fillScreen(BLUE);  
  }
  else
  if(!b==1){
  tft.fillScreen(WHITE);  
  delay(100);
  }

  if(up==1 || down==1 || left==1 || right==1){
  Process_mode=false;
  Serial.print(x, DEC);
  Serial.print(",");
  Serial.print(y, DEC);
  Serial.print(",");
  Serial.print(!b);
  
  Serial.print("\n");

  delay(10);
  }
   */
  b = digitalRead(SW);
  if(!b==1) {
    //tft.fillScreen(BLUE);
    m_n=true; 
    if(menu1==true){
      menu1=false;
      menu2=true;
    }else{
    if(menu2==true){
      menu2=false;
      menu1=true;
    }
    }
  }
}
